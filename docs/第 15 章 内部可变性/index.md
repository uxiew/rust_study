# 第 15 章 内部可变性

::: tip
内部可变性的实现是因为 Rust 使用了 `unsafe` 来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的 API 中
:::

Rust 的 borrow checker 的核心思想是“共享不可变，可变不共享”。但是只有这个规则是不够的，在某些情况下，我们的确需要在存在共享的情况下可变。为了让这种情况是可控的、安全的，Rust 还设计了一种“内部可变性”（interior mutability）。

“内部可变性”的概念，是与“承袭可变性”（inherited mutability）相对应的。大家应该注意到了，Rust 中的 mut 关键字不能在声明类型的时候使用，只能跟变量一起使用。
类型本身不能规定自己是否是可变的。一个变量是否是可变的，取决于它的使用环境，而不是它的类型。可变还是不可变取决于变量的使用方式，这就叫作“承袭可变性”。

如果我们用 `let var：T;` 声明，那么 var 是不可变的，同时，var 内部的所有成员也都是不可变的；如果我们用 `let mut var：T;` 声明，那么 var 是可变的，相应的，它的内部所有成员也都是可变的。

我们不能在类型声明的时候指定可变性，比如在 struct 中对某部分成员使用 `mut` 修饰，这是不合法的。我们只能在变量声明的时候指定可变性。我们也不能针对变量的某一部分成员指定可变性，其他部分保持不变。

常见的具备内部可变性特点的类型有 `Cell`、`RefCell`、`Mutex`、`RwLock`、`Atomic*` 等。其中 `Cell` 和 `RefCell` 是只能用在单线程环境下的具备内部可变性的类型。
下面就来讲解何为“内部可变性”。
